<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Socious Translator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: Inter, "Helvetica Neue", Arial, sans-serif; }
    .caret::after { content: " ▌"; opacity: .6; }
    #committed { display:block; white-space:normal; line-height:1.6; word-break:break-word; }
    #committed .seg::after { content:" "; }
  </style>
</head>
<body class="bg-[#111112] text-white min-h-screen flex flex-col items-center justify-start p-6 space-y-10">
  <h1 class="text-3xl font-bold tracking-tight text-center">Socious Translator</h1>

  <div class="w-full max-w-3xl bg-[#1A1A1C] rounded-2xl p-6 shadow-lg flex flex-col items-center space-y-6">
    <div class="w-full flex flex-col lg:flex-row lg:items-end lg:justify-center lg:gap-6 space-y-4 lg:space-y-0">
      <div class="flex flex-col w-full lg:w-auto items-center">
        <label for="direction" class="text-base font-medium mb-1">Translation Direction</label>
        <select id="direction" class="w-full lg:w-64 bg-[#2A2A2E] text-white border border-gray-700 rounded px-4 py-2 text-center">
          <option value="en-ja">English → Japanese</option>
          <option value="ja-en">Japanese → English</option>
        </select>
      </div>
      <div class="flex flex-col sm:flex-row gap-4">
        <button id="startBtn" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold px-6 py-2 rounded transition-all">Start Recording</button>
        <button id="stopBtn" disabled class="bg-gray-500 text-white font-semibold px-6 py-2 rounded opacity-50 cursor-not-allowed">Stop Recording</button>
      </div>
    </div>
    <div id="status" class="text-sm text-gray-400"></div>
  </div>

  <div class="w-full max-w-4xl flex flex-col space-y-6 items-center">
    <div class="w-full">
      <div id="output" class="bg-[#1A1A1C] rounded-lg px-6 py-10 shadow-md text-2xl font-semibold leading-8 tracking-wide min-h-[160px] w-full">
        <div id="committed"></div>
        <div id="active" class="caret mt-3 text-white"></div>
      </div>
    </div>
  </div>

  <!-- switched from type="module" to a classic script for Safari robustness -->
  <script defer>
  (function () {
    'use strict';

    const startBtn = document.getElementById("startBtn");
    const stopBtn  = document.getElementById("stopBtn");
    const directionSelect = document.getElementById("direction");
    const committed = document.getElementById("committed");
    const active    = document.getElementById("active");
    const statusEl  = document.getElementById("status");

    let ws, stream, recorder, pingTimer, chunkCount = 0, chunkWatchdog;
    const MAX_CHARS = 400;

    function wsUrl(){ return (location.protocol === "https:" ? "wss" : "ws") + "://" + location.host + "/ws"; }
    function setButtons(running){
      startBtn.disabled = running; stopBtn.disabled = !running;
      startBtn.classList.toggle("opacity-50", running);
      startBtn.classList.toggle("cursor-not-allowed", running);
      stopBtn.classList.toggle("opacity-50", !running);
      stopBtn.classList.toggle("cursor-not-allowed", !running);
    }
    function setStatus(t){ statusEl.textContent = t || ""; }
    function setActive(t){ if (active.textContent !== t) active.textContent = t; active.classList.toggle("caret", !!t); }
    function clearActive(){ setActive(""); }

    function trimToMax(){
      while (committed.innerText.length > MAX_CHARS && committed.firstElementChild) {
        committed.removeChild(committed.firstElementChild);
      }
    }
    function commit(text, id){
      const span = document.createElement("span");
      span.className = "seg";
      if (id) span.dataset.id = id;
      span.textContent = (text || "").trim();
      committed.appendChild(span);
      trimToMax();
      requestAnimationFrame(()=>{ window.scrollTo({ top: document.body.scrollHeight }); });
    }
    function handleMessage(data){
      if (typeof data !== "string") return;
      try {
        if (data.startsWith("[UPDATE]")) {
          const { id, text } = JSON.parse(data.slice(8));
          if (id === "live") setActive(text || "");
          return;
        }
        if (data.startsWith("[DONE]")) {
          const { id, text } = JSON.parse(data.slice(6));
          clearActive(); commit(text || "", id); return;
        }
      } catch(e){ console.warn("parse error", e); }
    }

    directionSelect.onchange = ()=> stopRecording();

    // Prefer Ogg (Firefox), then WebM, then MP4 (Safari)
    function pickCandidates(){
      return [
        "audio/ogg;codecs=opus",
        "audio/ogg",
        "audio/webm;codecs=opus",
        "audio/webm",
        "audio/mp4;codecs=mp4a.40.2",
        "audio/mp4"
      ];
    }

    async function makeRecorder(stream){
      const candidates = pickCandidates();
      for (const t of candidates) {
        try {
          if (window.MediaRecorder && typeof MediaRecorder.isTypeSupported === "function" && MediaRecorder.isTypeSupported(t)) {
            return new MediaRecorder(stream, { mimeType: t }); // no bitrate: steadier on Firefox
          }
        } catch(_) {}
      }
      // Fallback: let the browser choose a default
      return new MediaRecorder(stream);
    }

    function mimeToFormat(m){
      const mm = (m || "").toLowerCase();
      if (mm.indexOf("ogg")  >= 0) return "ogg";
      if (mm.indexOf("webm") >= 0) return "webm";
      if (mm.indexOf("mp4")  >= 0) return "mp4";
      return "";
    }

    async function startRecording(){
      try {
        setStatus("Requesting mic…");
        stream = await navigator.mediaDevices.getUserMedia({
          audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
        });

        ws = new WebSocket(wsUrl());
        ws.binaryType = "arraybuffer";

        ws.onopen = async () => {
          recorder = await makeRecorder(stream);
          const chosenMime = recorder.mimeType || "";
          const format = mimeToFormat(chosenMime);

          // tell server which container to expect
          ws.send(JSON.stringify({ direction: directionSelect.value, format }));
          setButtons(true);
          setStatus("Streaming… " + (chosenMime ? `[${chosenMime}]` : ""));

          chunkCount = 0;
          if (chunkWatchdog) clearTimeout(chunkWatchdog);
          chunkWatchdog = setTimeout(()=>{
            if (chunkCount === 0) {
              setStatus("No audio chunks yet — increasing slice…");
              try { if (recorder && recorder.state === "recording") recorder.stop(); } catch {}
              // restart with a larger slice
              startChunks(1000);
            }
          }, 3000);

          recorder.addEventListener("error", e=>{
            console.error("Recorder error", e);
            setStatus("Recorder error: " + (e.error && e.error.message || e.message || "unknown"));
          });

          function startChunks(sliceMs){
            try {
              recorder.ondataavailable = async (e) => {
                if (!e.data || e.data.size === 0) return;
                chunkCount++;
                const buf = await e.data.arrayBuffer();
                if (ws && ws.readyState === 1) ws.send(buf);
              };
              recorder.start(sliceMs); // 500–1000ms tends to be most robust
            } catch (err){
              console.error("startChunks error", err);
              setStatus("Recorder start failed: " + (err && err.message || err));
            }
          }

          startChunks(500);

          pingTimer = setInterval(()=>{
            if (ws && ws.readyState === 1) {
              try { ws.send(JSON.stringify({ type: "ping" })); } catch {}
            }
          }, 15000);
        };

        ws.onmessage = (e)=>handleMessage(e.data);
        ws.onclose   = ()=>{ setStatus("Disconnected"); setButtons(false); clearActive(); };
        ws.onerror   = (e)=>{ console.error(e); setStatus("WebSocket error"); };

      } catch (err){
        console.error(err);
        setStatus(err && err.message ? err.message : "Mic error");
        stopRecording();
      }
    }

    function stopRecording(){
      try { if (chunkWatchdog) clearTimeout(chunkWatchdog); } catch {}
      try { if (pingTimer) clearInterval(pingTimer); } catch {}
      try { if (recorder && recorder.state !== "inactive") recorder.stop(); } catch {}
      try { if (stream) stream.getTracks().forEach(t=>t.stop()); } catch {}
      try { if (ws && ws.readyState === 1) ws.close(); } catch {}
      setButtons(false); clearActive(); setStatus("");
    }

    startBtn.onclick = startRecording;
    stopBtn.onclick  = stopRecording;

    if (location.protocol !== "https:" && location.hostname !== "localhost" && location.hostname !== "127.0.0.1") {
      setStatus("Tip: Microphone requires HTTPS or localhost.");
    }

    // Surface real JS errors (useful on Safari)
    window.addEventListener('error',  (e)=> setStatus("JS error: " + (e.message || (e.error && e.error.message) || "unknown")));
    window.addEventListener('unhandledrejection', (e)=> setStatus("Promise error: " + (e.reason && e.reason.message || e.reason || "unknown")));
  })();
  </script>
</body>
</html>
