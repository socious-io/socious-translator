<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Socious Translator (Whisper large-v3)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: Inter, "Helvetica Neue", Arial, sans-serif; }
    .caret::after { content: " ▌"; opacity: .6; }
    #committed { display:block; white-space:normal; line-height:1.6; word-break:break-word; }
    #committed .seg::after { content:" "; }
  </style>
</head>
<body class="bg-[#111112] text-white min-h-screen flex flex-col items-center justify-start p-6 space-y-10">
  <h1 class="text-3xl font-bold tracking-tight text-center">Socious Translator</h1>

  <div class="w-full max-w-3xl bg-[#1A1A1C] rounded-2xl p-6 shadow-lg flex flex-col items-center space-y-6">
    <div class="w-full flex flex-col lg:flex-row lg:items-end lg:justify-center lg:gap-6 space-y-4 lg:space-y-0">
      <div class="flex flex-col w-full lg:w-auto items-center">
        <label for="direction" class="text-base font-medium mb-1">Translation Direction</label>
        <select id="direction" class="w-full lg:w-64 bg-[#2A2A2E] text-white border border-gray-700 rounded px-4 py-2 focus:outline-none text-center">
          <option value="en-ja">English → Japanese</option>
          <option value="ja-en">Japanese → English</option>
        </select>
      </div>
      <div class="flex flex-col sm:flex-row gap-4">
        <button id="startBtn" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold px-6 py-2 rounded transition-all">Start Recording</button>
        <button id="stopBtn" disabled class="bg-gray-500 text-white font-semibold px-6 py-2 rounded opacity-50 cursor-not-allowed">Stop Recording</button>
      </div>
    </div>
    <div id="status" class="text-sm text-gray-400"></div>
  </div>

  <div class="w-full max-w-4xl flex flex-col space-y-6 items-center">
    <div class="w-full">
      <div id="output" class="bg-[#1A1A1C] rounded-lg px-6 py-10 shadow-md text-2xl font-semibold leading-8 tracking-wide min-h-[160px] w-full">
        <div id="committed"></div>
        <div id="active" class="caret mt-3 text-white"></div>
      </div>
    </div>
  </div>

  <script type="module">
    const startBtn = document.getElementById("startBtn");
    const stopBtn  = document.getElementById("stopBtn");
    const directionSelect = document.getElementById("direction");
    const committed = document.getElementById("committed");
    const active    = document.getElementById("active");
    const statusEl  = document.getElementById("status");

    let ctx, node, stream, ws, timer;
    const MAX_CHARS = 400;
    const wsUrl = () => (location.protocol === "https:" ? "wss" : "ws") + "://" + location.host + "/ws";

    const setButtons = (running) => {
      startBtn.disabled = running;
      stopBtn.disabled  = !running;
      startBtn.classList.toggle("opacity-50", running);
      startBtn.classList.toggle("cursor-not-allowed", running);
      stopBtn.classList.toggle("opacity-50", !running);
      stopBtn.classList.toggle("cursor-not-allowed", !running);
    };
    const setStatus = (t) => statusEl.textContent = t || "";
    const setActive = (t) => { if (active.textContent !== t) active.textContent = t; active.classList.toggle("caret", !!t); };
    const clearActive = () => setActive("");

    function trimToMax() {
      while (committed.innerText.length > MAX_CHARS && committed.firstElementChild) {
        committed.removeChild(committed.firstElementChild);
      }
    }
    function commit(text, id=null) {
      const span = document.createElement("span");
      span.className = "seg";
      if (id) span.dataset.id = id;
      span.textContent = (text || "").trim();
      committed.appendChild(span);
      trimToMax();
      window.requestAnimationFrame(() => { window.scrollTo({ top: document.body.scrollHeight }); });
    }

    function handleMessage(data) {
      if (typeof data !== "string") return;
      try {
        if (data.startsWith("[UPDATE]")) {
          const { id, text } = JSON.parse(data.slice(8));
          if (id === "live") setActive(text || "");
          return;
        }
        if (data.startsWith("[DONE]")) {
          const { id, text } = JSON.parse(data.slice(6));
          clearActive();
          commit(text || "", id);
          return;
        }
      } catch(e) { console.warn("parse error", e); }
    }

    directionSelect.onchange = () => stopRecording();

    async function loadWorklet(ctx, url) {
      // Try normal path
      try {
        await ctx.audioWorklet.addModule(`${url}?v=${Date.now()}`);
        console.log("AudioWorklet loaded via URL");
        return;
      } catch (e) {
        console.warn("addModule(url) failed:", e);
      }
      // Fetch + sanity-check
      const r = await fetch(`${url}?v=${Date.now()}`, { cache: "no-store" });
      if (!r.ok) throw new Error(`Worklet HTTP ${r.status}`);
      const code = await r.text();
      const head = code.slice(0, 256);
      if (/<!doctype html/i.test(head) || /<html[\s>]/i.test(head)) {
        throw new Error("Worklet fetch returned HTML (404/redirect).");
      }
      // Blob fallback (bypasses bad MIME/CSP quirks)
      const blob = new Blob([code], { type: "application/javascript" });
      const blobURL = URL.createObjectURL(blob);
      try {
        await ctx.audioWorklet.addModule(blobURL);
        console.log("AudioWorklet loaded via Blob URL");
      } finally {
        URL.revokeObjectURL(blobURL);
      }
    }


    async function startRecording() {
      // Helper: robustly load the worklet (URL → Blob fallback) with clear errors
      async function loadWorklet(ctx, url) {
        try {
          await ctx.audioWorklet.addModule(`${url}?v=${Date.now()}`);
          console.log("AudioWorklet loaded via URL");
          return;
        } catch (e) {
          console.warn("addModule(url) failed:", e);
        }
        const r = await fetch(`${url}?v=${Date.now()}`, { cache: "no-store" });
        if (!r.ok) throw new Error(`Worklet HTTP ${r.status} ${r.statusText}`);
        const code = await r.text();
        const head = code.slice(0, 256);
        if (/<!doctype html/i.test(head) || /<html[\s>]/i.test(head)) {
          throw new Error("Worklet fetch returned HTML (404/redirect/CSP).");
        }
        const blob = new Blob([code], { type: "application/javascript" });
        const blobURL = URL.createObjectURL(blob);
        try {
          await ctx.audioWorklet.addModule(blobURL);
          console.log("AudioWorklet loaded via Blob URL");
        } finally {
          URL.revokeObjectURL(blobURL);
        }
      }

      try {
        setStatus("Requesting mic…");
        stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            sampleRate: 48000,            // nudges stable input rate
            channelCount: 1,
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });

        ctx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: "interactive" });
        if (ctx.state === "suspended") await ctx.resume();
        ctx.onstatechange = () => {
          console.log("AudioContext:", ctx.state);
          if (ctx.state === "suspended") ctx.resume().catch(()=>{});
        };

        // Load the worklet robustly (uses /static route you already serve)
        await loadWorklet(ctx, "/static/pcm-capture.worklet.js");

        const source = ctx.createMediaStreamSource(stream);
        node = new AudioWorkletNode(ctx, "pcm-capture", {
          processorOptions: { downsampleTo: 16000, frameMs: 20 },
          numberOfInputs: 1,
          numberOfOutputs: 1,
          outputChannelCount: [1]
        });

        // Keep the graph “audible” so engines keep pulling (no audible echo)
        const keep = ctx.createGain();
        keep.gain.value = 0.0;
        source.connect(keep).connect(ctx.destination);

        // Normal path into the worklet; also connect node → destination
        source.connect(node);
        node.connect(ctx.destination);

        // WebSocket setup
        ws = new WebSocket(wsUrl());
        ws.binaryType = "arraybuffer";
        ws.onopen = () => {
          try { ws.send(JSON.stringify({ direction: directionSelect.value })); } catch {}
          setButtons(true);
          setStatus("Streaming…");
          timer = setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: "ping" }));
            }
          }, 15000);
        };
        ws.onmessage = (e) => handleMessage(e.data);
        ws.onclose = () => { setStatus("Disconnected"); setButtons(false); clearActive(); };
        ws.onerror = (e) => { console.error("WebSocket error:", e); setStatus("WebSocket error"); };

        // Forward frames from the worklet → WS, with backpressure guard and logging
        let posted = 0, lastLog = performance.now();
        node.port.onmessage = (e) => {
          if (ws && ws.readyState === WebSocket.OPEN) {
            if (ws.bufferedAmount < 512 * 1024) {
              ws.send(e.data);            // e.data is an ArrayBuffer
            } else {
              // Drop frame if socket is backpressured to avoid deadlock
            }
          }
          posted++;
          const now = performance.now();
          if (now - lastLog > 1000) {
            console.log(`worklet → WS frames: ${posted}/s, buffered=${ws ? ws.bufferedAmount : 0}`);
            posted = 0; lastLog = now;
          }
        };
        node.onprocessorerror = (e) => console.error("AudioWorklet error:", e);

      } catch (err) {
        console.error(err);
        setStatus(err && err.message ? err.message : "Mic/Worklet error");
        stopRecording();
      }
    }


    function stopRecording() {
      try { clearInterval(timer); } catch {}
      try { node && (node.port.onmessage = null); } catch {}
      try { stream?.getTracks().forEach(t=>t.stop()); } catch {}
      try { ctx && ctx.close(); } catch {}
      try { ws && ws.readyState === WebSocket.OPEN && ws.close(); } catch {}
      setButtons(false);
      clearActive();
    }

    startBtn.onclick = startRecording;
    stopBtn.onclick  = stopRecording;

    if (location.protocol !== "https:" && location.hostname !== "localhost" && location.hostname !== "127.0.0.1") {
      setStatus("Tip: Microphone requires HTTPS or localhost.");
    }
  </script>
</body>
</html>