<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Socious Translator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: 'Inter', 'Helvetica Neue', sans-serif; }
    .caret::after { content: ' ▌'; opacity: 0.6; }
    /* Make the output look like one flowing paragraph */
    #committed { display: block; white-space: normal; line-height: 1.6; word-break: break-word; }
    #committed .seg::after { content: " "; } /* space between segments */
  </style>
</head>
<body class="bg-[#111112] text-white min-h-screen flex flex-col items-center justify-start p-6 space-y-10">

  <h1 class="text-3xl font-bold tracking-tight text-center">Socious Translator</h1>

  <!-- Controls -->
  <div class="w-full max-w-3xl bg-[#1A1A1C] rounded-2xl p-6 shadow-lg flex flex-col items-center space-y-6">
    <div class="w-full flex flex-col lg:flex-row lg:items-end lg:justify-center lg:gap-6 space-y-4 lg:space-y-0">
      <div class="flex flex-col w-full lg:w-auto items-center">
        <label for="direction" class="text-base font-medium mb-1">Translation Direction</label>
        <select id="direction" class="w-full lg:w-64 bg-[#2A2A2E] text-white border border-gray-700 rounded px-4 py-2 focus:outline-none text-center">
          <option value="en-ja">English → Japanese</option>
          <option value="ja-en">Japanese → English</option>
        </select>
      </div>
      <div class="flex flex-col sm:flex-row gap-4">
        <button id="startBtn" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold px-6 py-2 rounded transition-all">Start Recording</button>
        <button id="stopBtn" disabled class="bg-gray-500 text-white font-semibold px-6 py-2 rounded opacity-50 cursor-not-allowed">Stop Recording</button>
      </div>
    </div>
    <div id="status" class="text-sm text-gray-400"></div>
  </div>

  <!-- Output -->
  <div class="w-full max-w-4xl flex flex-col space-y-6 items-center">
    <div class="w-full">
      <div id="output" class="bg-[#1A1A1C] rounded-lg px-6 py-10 shadow-md text-2xl font-semibold leading-8 tracking-wide min-h-[160px] w-full">
        <div id="committed"></div>
        <div id="active" class="caret mt-3 text-white"></div>
      </div>
    </div>
  </div>

  <script>
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const directionSelect = document.getElementById("direction");
    const committed = document.getElementById("committed");
    const active = document.getElementById("active");
    const statusEl = document.getElementById("status");

    let mediaStream = null;
    let socket = null;
    let recording = false;

    const MAX_CHARS = 110; // cap the paragraph length for live readability

    // use a template literal for WebSocket URL
    function wsUrl() {
      const proto = location.protocol === "https:" ? "wss" : "ws";
      return `${proto}://${location.host}/ws`;
    }


    directionSelect.onchange = () => stopRecording();

    function setButtons(running) {
      startBtn.disabled = running;
      stopBtn.disabled = !running;
      startBtn.classList.toggle("opacity-50", running);
      startBtn.classList.toggle("cursor-not-allowed", running);
      stopBtn.classList.toggle("opacity-50", !running);
      stopBtn.classList.toggle("cursor-not-allowed", !running);
    }

    function setStatus(text) {
      statusEl.textContent = text || "";
    }

    function setActivePartial(text) {
      active.textContent = text || "";
      active.classList.toggle("caret", !!text);
    }

    function clearActivePartial() {
      setActivePartial("");
    }

    function totalChars() {
      return committed.innerText.length;
    }

    function trimToMaxChars() {
      let extra = totalChars() - MAX_CHARS;
      while (extra > 0 && committed.firstChild) {
        const node = committed.firstChild;
        const txt = node.textContent || "";
        if (txt.length <= extra) {
          committed.removeChild(node);
          extra -= txt.length;
        } else {
          // trim from the start of this node so the total visible chars == MAX_CHARS
          node.textContent = txt.slice(extra);
          extra = 0;
        }
      }
    }


    function commitFinal(text, id = null) {
      const span = document.createElement("span");
      span.className = "seg";
      if (id) span.dataset.id = id;
      span.textContent = (text || "").trim();
      committed.appendChild(span);
      trimToMaxChars();
      // Auto-scroll to bottom
      window.requestAnimationFrame(() => {
        window.scrollTo({ top: document.body.scrollHeight, behavior: "smooth" });
      });
    }

    // Backend only sends [DONE] and [UPDATE]
    function handleMessage(data) {
      try {
        if (typeof data !== "string") return;
        if (data.startsWith("[DONE]")) {
          const { id, text } = JSON.parse(data.replace("[DONE]", ""));
          clearActivePartial();
          commitFinal(text || "", id);
          return;
        }
        if (data.startsWith("[UPDATE]")) {
          const { id, text } = JSON.parse(data.replace("[UPDATE]", ""));
          if (id) {
            // FIXED: valid selector string
            const target = committed.querySelector(`[data-id="${id}"]`);
            if (target) {
              target.textContent = (text || "").trim();
              trimToMaxChars();
            }
          }
          return;
        }
        // Ignore any other message types
      } catch (e) {
        console.warn("Message parse error:", e);
      }
    }

    async function startRecording() {
      try {
        // Feature checks
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error("getUserMedia is not available in this browser/context.");
        }
        if (!("MediaRecorder" in window)) {
          throw new Error("MediaRecorder API not supported in this browser.");
        }

        const preferred = [
          "audio/ogg;codecs=opus",
          "audio/webm;codecs=opus",
          "audio/webm"
        ];
        let mimeType = "";
        for (const t of preferred) {
          try {
            if (MediaRecorder.isTypeSupported(t)) { mimeType = t; break; }
          } catch { /* older browsers may throw; ignore */ }
        }
        if (!mimeType) {
          throw new Error("No supported audio MIME type (WebM/Opus) found.");
        }

        // (Optional) surface current permission state where supported
        if (navigator.permissions && navigator.permissions.query) {
          try {
            const p = await navigator.permissions.query({ name: "microphone" });
            setStatus(`Microphone permission: ${p.state}`);
          } catch { /* permissions API not available */ }
        }

        // This is where the prompt should appear
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });

        setStatus("Connecting…");
        socket = new WebSocket(wsUrl());

        socket.onopen = () => {
          try {
            socket.send(JSON.stringify({ direction: directionSelect.value }));
          } catch {}
          recording = true;
          setButtons(true);
          setStatus("Recording…");
          recordLoop(mimeType);
        };

        socket.onmessage = (e) => handleMessage(e.data);

        socket.onclose = () => {
          setButtons(false);
          setActivePartial("");
          setStatus("Disconnected");
          recording = false; // ensure loop stops if socket drops
        };

        socket.onerror = (e) => {
          console.error("WebSocket error:", e);
          setStatus("WebSocket error");
        };

      } catch (err) {
        console.error("Error starting recording:", err);
        setStatus(
          (err && err.name) ? `Mic error: ${err.name}` :
          (err && err.message) ? `Mic error: ${err.message}` :
          "Mic error"
        );
        stopRecording();
      }
    }

    async function recordLoop(mimeType) {
      let recorder;
      try {
        recorder = new MediaRecorder(mediaStream, { mimeType });
      } catch (e) {
        console.error("Failed to create MediaRecorder:", e);
        setStatus("Failed to create MediaRecorder");
        stopRecording();
        return;
      }

      // accumulate ~4s before sending
      let acc = [];
      let accBytes = 0;
      const FLUSH_MS = 3800;

      function flush(now = performance.now()) {
        if (!acc.length || socket?.readyState !== WebSocket.OPEN) return;
        const blob = new Blob(acc, { type: acc[0].type || mimeType });
        acc = [];
        accBytes = 0;
        blob.arrayBuffer().then(buf => socket.send(buf)).catch(err => {
          console.warn("send buffer error:", err);
        });
        lastFlush = now;
      }

      let lastFlush = performance.now();

      recorder.ondataavailable = (e) => {
        if (!e.data || e.data.size === 0) return;
        acc.push(e.data);
        accBytes += e.data.size;

        const now = performance.now();
        // flush if we've got ~4s of audio or it’s been ~3.8s since last flush
        if (accBytes > 0 && (now - lastFlush >= FLUSH_MS || acc.length >= 4)) {
          flush(now);
        }
      };

      // ensure we still flush occasionally (e.g., when page is backgrounded)
      const flushTimer = setInterval(() => flush(), 1000);

      try { recorder.start(1000); } catch (e) {
        console.error("MediaRecorder start failed:", e);
        setStatus("MediaRecorder start failed");
        clearInterval(flushTimer);
        stopRecording();
        return;
      }

      await new Promise((resolve) => {
        recorder.onstop = () => {
          clearInterval(flushTimer);
          flush(); // send any final buffered audio
          resolve();
        };
      });
    }



    function stopRecording() {
      recording = false;
      try { mediaStream?.getTracks().forEach(t => t.stop()); } catch {}
      try { socket && socket.readyState === WebSocket.OPEN && socket.close(); } catch {}
      setActivePartial("");
      setButtons(false);
      // don't overwrite error messages
      if (!statusEl.textContent) setStatus("");
    }

    startBtn.onclick = startRecording;
    stopBtn.onclick = stopRecording;

    // Small UX niceties: warn if not secure context (no prompt will appear)
    if (location.protocol !== "https:" && location.hostname !== "localhost" && location.hostname !== "127.0.0.1") {
      setStatus("Tip: Microphone requires HTTPS or localhost.");
    }
  </script>
</body>
</html>
